import { Rule, RuleStatus } from '../../common/types/RuleTypes';
import { ruleService } from '../../common/services/RuleService';
import { RouteUtils } from '../../common/router/Router';
import { LoadingComponent, RefreshLoading } from '../../common/components/LoadingComponent';

/**
 * çŠ¶æ€é€‰é¡¹æ¥å£
 */
interface StatusOption {
  value: string;
  label: string;
}

/**
 * è§„åˆ™åˆ—è¡¨é¡µé¢
 */
@Component
export struct RulesPage {
  @State rules: Rule[] = [];
  @State isLoading: boolean = false;
  @State isRefreshing: boolean = false;
  @State searchKeyword: string = '';
  @State selectedStatus: string = 'all';
  @State showSearchBar: boolean = false;

  // çŠ¶æ€é€‰é¡¹
  private statusOptions: StatusOption[] = [
    this.createStatusOption('all', 'å…¨éƒ¨'),
    this.createStatusOption('enabled', 'å·²å¯ç”¨'),
    this.createStatusOption('disabled', 'å·²ç¦ç”¨'),
    this.createStatusOption('error', 'é”™è¯¯')
  ];

  /**
   * åˆ›å»ºçŠ¶æ€é€‰é¡¹
   */
  private createStatusOption(value: string, label: string): StatusOption {
    return {
      value: value,
      label: label
    };
  }

  /**
   * åˆ›å»ºæœç´¢å‚æ•°
   */
  private createSearchParams(): Record<string, string | number | boolean> {
    const params: Record<string, string | number | boolean> = {};

    if (this.searchKeyword) {
      params.keyword = this.searchKeyword;
    }

    if (this.selectedStatus !== 'all') {
      params.status = this.selectedStatus;
    }

    params.sortBy = 'updatedAt';
    params.sortOrder = 'desc';

    return params;
  }

  aboutToAppear() {
    this.loadRules();
  }

  /**
   * åŠ è½½è§„åˆ™åˆ—è¡¨
   */
  private async loadRules() {
    this.isLoading = true;
    
    try {
      const searchParams = this.createSearchParams();
      
      this.rules = await ruleService.getRules(searchParams);
      console.info(`[RulesPage] Loaded ${this.rules.length} rules`);
    } catch (error) {
      console.error('[RulesPage] Failed to load rules:', error);
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * åˆ·æ–°è§„åˆ™åˆ—è¡¨
   */
  private async refreshRules() {
    this.isRefreshing = true;
    await this.loadRules();
    this.isRefreshing = false;
  }

  /**
   * æœç´¢è§„åˆ™
   */
  private async searchRules() {
    await this.loadRules();
  }

  /**
   * åˆ‡æ¢è§„åˆ™çŠ¶æ€
   */
  private async toggleRule(rule: Rule) {
    try {
      const updatedRule = await ruleService.toggleRule(rule.id, !rule.enabled);
      if (updatedRule) {
        // æ›´æ–°æœ¬åœ°çŠ¶æ€
        const index = this.rules.findIndex(r => r.id === rule.id);
        if (index >= 0) {
          this.rules[index] = updatedRule;
        }
      }
    } catch (error) {
      console.error('[RulesPage] Failed to toggle rule:', error);
    }
  }

  /**
   * åˆ é™¤è§„åˆ™
   */
  private async deleteRule(rule: Rule) {
    try {
      const success = await ruleService.deleteRule(rule.id);
      if (success) {
        this.rules = this.rules.filter(r => r.id !== rule.id);
      }
    } catch (error) {
      console.error('[RulesPage] Failed to delete rule:', error);
    }
  }

  build() {
    Column() {
      // æ ‡é¢˜æ 
      this.buildHeader()

      // æœç´¢æ 
      if (this.showSearchBar) {
        this.buildSearchBar()
      }

      // ç­›é€‰æ 
      this.buildFilterBar()

      // åˆ·æ–°æŒ‡ç¤ºå™¨
      RefreshLoading({
        refreshing: this.isRefreshing,
        message: 'æ­£åœ¨åˆ·æ–°è§„åˆ™åˆ—è¡¨...'
      })

      // è§„åˆ™åˆ—è¡¨
      if (this.isLoading) {
        LoadingComponent({
          visible: true,
          message: 'åŠ è½½è§„åˆ™ä¸­...'
        })
      } else {
        this.buildRuleList()
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F8F9FA')
  }

  /**
   * æ„å»ºæ ‡é¢˜æ 
   */
  @Builder
  buildHeader() {
    Row() {
      Text('è§„åˆ™ç®¡ç†')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .layoutWeight(1)

      // æœç´¢æŒ‰é’®
      Button() {
        Text('ğŸ”')
          .fontSize(16)
      }
      .width(40)
      .height(40)
      .backgroundColor(Color.Transparent)
      .onClick(() => {
        this.showSearchBar = !this.showSearchBar;
      })

      // æ–°å»ºæŒ‰é’®
      Button('æ–°å»º')
        .fontSize(14)
        .backgroundColor(Color.Blue)
        .borderRadius(16)
        .margin({ left: 8 })
        .onClick(async () => {
          console.info('[RulesPage] æ–°å»ºæŒ‰é’®è¢«ç‚¹å‡»');
          try {
            await RouteUtils.toRuleCreate();
            console.info('[RulesPage] è·¯ç”±è·³è½¬æˆåŠŸ');
          } catch (error) {
            console.error('[RulesPage] è·¯ç”±è·³è½¬å¤±è´¥:', error);
          }
        })
    }
    .width('100%')
    .height(56)
    .padding({ left: 16, right: 16 })
    .backgroundColor(Color.White)
  }

  /**
   * æ„å»ºæœç´¢æ 
   */
  @Builder
  buildSearchBar() {
    Row({ space: 8 }) {
      TextInput({ placeholder: 'æœç´¢è§„åˆ™åç§°æˆ–æè¿°' })
        .layoutWeight(1)
        .onChange((value: string) => {
          this.searchKeyword = value;
        })
        .onSubmit(() => {
          this.searchRules();
        })

      Button('æœç´¢')
        .fontSize(14)
        .backgroundColor(Color.Blue)
        .onClick(() => {
          this.searchRules();
        })
    }
    .width('100%')
    .padding(16)
    .backgroundColor(Color.White)
  }

  /**
   * æ„å»ºç­›é€‰æ 
   */
  @Builder
  buildFilterBar() {
    Row({ space: 8 }) {
      Text('çŠ¶æ€:')
        .fontSize(14)
        .fontColor(Color.Gray)

      ForEach(this.statusOptions, (option: StatusOption) => {
        Button(option.label)
          .fontSize(12)
          .backgroundColor(this.selectedStatus === option.value ? Color.Blue : '#E0E0E0')
          .fontColor(this.selectedStatus === option.value ? Color.White : Color.Black)
          .borderRadius(12)
          .padding({ left: 12, right: 12, top: 4, bottom: 4 })
          .onClick(() => {
            this.selectedStatus = option.value;
            this.loadRules();
          })
      })

      Blank()

      Button('åˆ·æ–°')
        .fontSize(12)
        .backgroundColor('#E0E0E0')
        .fontColor(Color.Black)
        .borderRadius(12)
        .padding({ left: 12, right: 12, top: 4, bottom: 4 })
        .onClick(() => {
          this.refreshRules();
        })
    }
    .width('100%')
    .padding({ left: 16, right: 16, top: 8, bottom: 8 })
    .backgroundColor(Color.White)
  }

  /**
   * æ„å»ºè§„åˆ™åˆ—è¡¨
   */
  @Builder
  buildRuleList() {
    if (this.rules.length === 0) {
      Column() {
        Text('ğŸ“')
          .fontSize(48)
          .margin({ bottom: 16 })

        Text('æš‚æ— è§„åˆ™')
          .fontSize(16)
          .fontColor(Color.Gray)
          .margin({ bottom: 8 })

        Text('ç‚¹å‡»å³ä¸Šè§’"æ–°å»º"æŒ‰é’®åˆ›å»ºç¬¬ä¸€ä¸ªè§„åˆ™')
          .fontSize(14)
          .fontColor('#999999')

        Button('ç«‹å³åˆ›å»º')
          .fontSize(14)
          .backgroundColor(Color.Blue)
          .borderRadius(16)
          .margin({ top: 20 })
          .onClick(() => {
            RouteUtils.toRuleCreate();
          })
      }
      .width('100%')
      .layoutWeight(1)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    } else {
      List({ space: 8 }) {
        ForEach(this.rules, (rule: Rule) => {
          ListItem() {
            this.buildRuleItem(rule)
          }
        })
      }
      .width('100%')
      .layoutWeight(1)
      .padding({ left: 16, right: 16, top: 8, bottom: 8 })
      .scrollBar(BarState.Auto)
    }
  }

  /**
   * æ„å»ºè§„åˆ™é¡¹
   */
  @Builder
  buildRuleItem(rule: Rule) {
    Column() {
      Row() {
        // çŠ¶æ€æŒ‡ç¤ºå™¨
        Circle()
          .width(8)
          .height(8)
          .fill(this.getStatusColor(rule.status))
          .margin({ right: 12 })

        // è§„åˆ™ä¿¡æ¯
        Column({ space: 4 }) {
          Text(rule.name)
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .maxLines(1)
            .textOverflow({ overflow: TextOverflow.Ellipsis })

          if (rule.description) {
            Text(rule.description)
              .fontSize(14)
              .fontColor('#666666')
              .maxLines(2)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
          }

          Row({ space: 16 }) {
            Text(`è§¦å‘å™¨: ${rule.trigger.pluginName}`)
              .fontSize(12)
              .fontColor('#999999')

            Text(`åŠ¨ä½œ: ${rule.actions.length}ä¸ª`)
              .fontSize(12)
              .fontColor('#999999')

            Text(`æ‰§è¡Œ: ${rule.executionCount}æ¬¡`)
              .fontSize(12)
              .fontColor('#999999')
          }
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)

        // å¼€å…³
        Toggle({ type: ToggleType.Switch, isOn: rule.enabled })
          .onChange((isOn: boolean) => {
            this.toggleRule(rule);
          })
      }
      .width('100%')
      .alignItems(VerticalAlign.Top)

      // æ“ä½œæŒ‰é’®
      Row({ space: 8 }) {
        Button('è¯¦æƒ…')
          .fontSize(12)
          .backgroundColor('#E3F2FD')
          .fontColor(Color.Blue)
          .borderRadius(8)
          .onClick(() => {
            RouteUtils.toRuleDetail(rule.id);
          })

        Button('ç¼–è¾‘')
          .fontSize(12)
          .backgroundColor('#E8F5E8')
          .fontColor('#4CAF50')
          .borderRadius(8)
          .onClick(() => {
            RouteUtils.toRuleEdit(rule.id);
          })

        Button('åˆ é™¤')
          .fontSize(12)
          .backgroundColor('#FFEBEE')
          .fontColor('#F44336')
          .borderRadius(8)
          .onClick(() => {
            this.deleteRule(rule);
          })

        Blank()

        Text(this.formatTime(rule.updatedAt))
          .fontSize(12)
          .fontColor('#999999')
      }
      .width('100%')
      .margin({ top: 8 })
    }
    .width('100%')
    .padding(16)
    .backgroundColor(Color.White)
    .borderRadius(8)
    .shadow({
      radius: 4,
      color: '#00000010',
      offsetX: 0,
      offsetY: 2
    })
    .onClick(() => {
      RouteUtils.toRuleDetail(rule.id);
    })
  }

  /**
   * è·å–çŠ¶æ€é¢œè‰²
   */
  private getStatusColor(status: RuleStatus): Color {
    switch (status) {
      case RuleStatus.ENABLED:
        return Color.Green;
      case RuleStatus.DISABLED:
        return Color.Gray;
      case RuleStatus.ERROR:
        return Color.Red;
      default:
        return Color.Gray;
    }
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´
   */
  private formatTime(timestamp: number): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();

    if (diff < 60000) { // 1åˆ†é’Ÿå†…
      return 'åˆšåˆš';
    } else if (diff < 3600000) { // 1å°æ—¶å†…
      return `${Math.floor(diff / 60000)}åˆ†é’Ÿå‰`;
    } else if (diff < 86400000) { // 1å¤©å†…
      return `${Math.floor(diff / 3600000)}å°æ—¶å‰`;
    } else {
      return `${date.getMonth() + 1}/${date.getDate()}`;
    }
  }
}
